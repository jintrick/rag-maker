# Issue v0.5.0: 既存ナレッジベースの再取得（更新）機能の実装

## 前提知識
- docs/Architecture/Architecture.md
- .gemini/commands/rag.toml
- docs/issue/v0.4.5.md (本イシューの前提となるアーキテクチャ変更)

## 経緯
`v0.4.5` の実装により、各ナレッジベースの `cache/discovery.json` に、その由来となるソースURLや取得日時を記録する `header` が追加されました。
しかし、現状ではこの情報を活用する仕組みがなく、一度作成したナレッジベースは、元のソースが更新されても古い情報のままになってしまいます。

ナレッジベースの鮮度を保ち、価値を維持するためには、既存のナレッジベースを元のソースから簡単に更新できる機能が必要です。

## 現状の問題点
1.  **ナレッジベースの陳腐化**: 元のWebサイトやGitHubリポジトリが更新されても、作成済みのナレッジベースにその変更を反映する手段がありません。
2.  **非効率な手動更新**: ナレッジベースを最新の状態にするには、ユーザーが手動で古いナレッジベースのディレクトリを削除し、同じソースURLを指定して `/rag` コマンドを再実行する必要があります。これは非常に手間がかかります。

## 解決策の概要
`/rag` コマンドのワークフローを拡張し、既存のナレッジベースを対象とした場合に、そのナレッジベースの `header` に記録されたソースURLから情報を再取得して内容を更新する機能を追加します。

## 解決策の詳細
1.  **`.gemini/commands/rag.md` のワークフロー修正**:
    -   `### 0. ナレッジベースのセットアップ` のロジックを拡張します。
    -   ユーザーが `ask_dir` で既存のナレッジベースを選択した後、AIエージェントは `<KB_ROOT>/cache/discovery.json` が存在するか確認します。
    -   ファイルが存在し、かつ `header.source_url` キーが含まれている場合、エージェントは「このナレッジベースをソース（`{source_url}`）から更新しますか？」とユーザーに確認します。
    -   ユーザーが「はい」と答えた場合、エージェントは `header.source_url` を取得し、後続のデータ取得ステップのソースとして使用します。

2.  **データ取得ツールの機能拡張**:
    -   `http_fetch.py` と `github_fetch.py` に、`--clean-output-dir` というフラグを追加します。
    -   このフラグが指定された場合、ツールはデータを取得する前に、`--output-dir` で指定されたディレクトリの中身を一度すべて削除します。これにより、古いキャッシュファイルと新しいファイルが混在するのを防ぎます。

3.  **AIエージェントへの指示更新**:
    -   `.gemini/commands/rag.md` の `### 1. データ取得` セクションを更新します。
    -   ナレッジベースの更新時（ステップ0でユーザーが更新を承認した場合）には、`http_fetch` や `github_fetch` を呼び出す際に `--clean-output-dir` フラグを付けるよう、AIエージェントに明確に指示します。

## 参考とすべきスクリプト等
- `.gemini/commands/rag.md` (修正対象)
- `src/ragmaker/tools/http_fetch.py` (修正対象)
- `src/ragmaker/tools/github_fetch.py` (修正対象)

## テスト方法
1.  **データ取得ツールの単体テスト**:
    -   `--clean-output-dir` フラグが正しく機能することを検証するテストケースを追加します。
2.  **`/rag` コマンドの統合テスト**:
    -   まず、一度 `/rag` を実行して通常のナレッジベースを作成します。
    -   再度 `/rag` を実行し、今作成したナレッジベースのディレクトリを選択します。
    -   エージェントが更新の確認を求め、承認すると、`cache` ディレクトリが一度クリーンアップされ、再度データが取得される一連のフローが正しく実行されることを確認します。

## 実装状況