# Issue v0.8.3: browser_fetch の致命的エラーによる即時停止と対話モードの安定化

## 前提知識
- `src/ragmaker/tools/browser_fetch.py`
- Playwright Error Handling (`playwright.async_api.Error`)

## 経緯
`v0.8.2` までの `browser_fetch` は、ブラウザがクラッシュしたり閉じられたりした場合（`TargetClosedError`）でも、再帰ループが停止せず、死んだブラウザに対してリクエストを送り続ける「ゾンビループ」が発生していた。また、対話モード（非ヘッドレス）においてタイムアウトが短すぎるため、ユーザーが検証操作を行っている最中にページが自動で閉じられ、進行がリセットされる問題も確認された。

## 現状の問題点
- ブラウザやコンテキストが消失した際のエラーハンドリングがページ単位に閉じており、全体ループを中断する仕組みがない。
- インタラクティブモードでも一律のタイムアウト（60秒）が適用されており、複雑な検証（ログイン、パスワード考案等）に対応できない。
- 回復不能なエラー発生時、同じエラーメッセージが大量に出力され、リソースを浪費する。

## ゴール（完了の定義）
- [ ] `TargetClosedError` 等の致命的なブラウザエラーを検知した場合、再帰ループ（`run` メソッド）を即座に `break` し、安全に終了する。
- [ ] `--no-headless` が有効な場合、ページ遷移のタイムアウトを無期限（0）に設定し、ユーザー操作を妨げないようにする。
- [ ] 途中で停止した場合でも、それまでに取得成功したドキュメントのみで `catalog.json` を正常に出力する。
- [ ] 致命的エラー時のスタックトレース連打を抑制し、原因を 1 度だけ明確に stderr へ出力する。

## 解決策の概要
`WebFetcher` 内にカスタム例外 `FatalBrowserError` を導入し、`_process_page` でブラウザ消失を検知した際にこれを送出する。`run` メソッドはこの例外をキャッチしてループを中断し、最終的なカタログ出力処理へ移行する。また、`no_headless` フラグに連動して `page.goto` の `timeout` を 0 (無制限) に切り替える。

## 解決策の詳細

### 1. カスタム例外の定義
`src/ragmaker/tools/browser_fetch.py` の `WebFetcher` クラス定義の直前に以下を定義する。
```python
class FatalBrowserError(Exception):
    """Raised when the browser or context is closed and further fetching is impossible."""
    pass
```

### 2. エラー判別メソッドの追加
`WebFetcher` クラスに、例外が致命的（ブラウザ閉鎖等）かどうかを判定するメソッドを追加する。
```python
    def _is_fatal_error(self, e: Exception) -> bool:
        """Determines if the exception indicates a fatal browser loss."""
        msg = str(e).lower()
        fatal_keywords = ["closed", "connection closed", "target closed", "context closed"]
        return any(k in msg for k in fatal_keywords)
```

### 3. エラーハンドリングの強化 (`_process_page`)
- `page.goto(url, timeout=..., ...)` において、`timeout` 引数を `0 if self.no_headless else 60000` に設定する。
- `page.goto` を囲む `try...except` において、`self._is_fatal_error(e)` が `True` の場合は `FatalBrowserError` を `raise` する。
- `_process_page` 全体を囲む `try...except Exception as e:` においても、同様に `self._is_fatal_error(e)` をチェックし、致命的であれば `FatalBrowserError` を送出、そうでなければ `handle_request_error` を呼び出す。

### 4. ループの中断実装 (`run`)
`run` メソッドの `while urls_to_visit:` ループ内で `_process_page` を呼び出している箇所を `try...except FatalBrowserError` で保護する。
- 捕捉時は `logger.error(f"Fatal browser error: {e}. Stopping crawl.")` を実行し、`break` する。

### 5. タイムアウト 0 のリスクと対策
- **リスク**: ネットワークが不安定な場合や、特定のスクリプトが通信を維持し続ける場合に `networkidle` 待ちが永遠に終わらない可能性がある。
- **対策**: `--no-headless` モードはユーザーの監視下にあるため、ハング時はユーザーがブラウザを手動で閉じることで対応する。ブラウザ閉鎖は `FatalBrowserError` として検知され、安全に中断処理（カタログ出力）が行われる。

## 実装手順

1.  `src/ragmaker/tools/browser_fetch.py` を開き、`WebFetcher` クラスの前に `FatalBrowserError` を追加。
2.  `WebFetcher` クラス内に `_is_fatal_error` メソッドを追加。
3.  `_process_page` メソッドの `page.goto` のタイムアウト設定を修正し、致命的エラーのチェックを追加。
4.  `run` メソッドのループ内に `FatalBrowserError` のキャッチと `break` 処理を追加。
5.  `test/test_browser_fetch.py` を実行し、既存機能が壊れていないことを確認。
6.  `test/test_browser_fetch_fatal.py` を作成し、ブラウザ閉鎖時の挙動をモックを用いてテストする。

## テスト方法
- **自動テスト**: `pytest test/test_browser_fetch_fatal.py`
    - `page.goto` が `TargetClosedError` を模した例外を投げた際、`WebFetcher.run` が途中で止まり、例外が外に漏れずに正常終了することを確認する。
- **手動テスト**:
    - `python -m ragmaker.tools.browser_fetch --url https://example.com --base-url https://example.com --output-dir tmp --no-headless` を実行。
    - ブラウザ表示中にウィンドウを閉じる。
    - ターミナルに `Fatal browser error` が表示され、`tmp/catalog.json` が生成されることを確認。

## 実装状況
Status: drafting
- [ ] 致命的エラーの定義と送出
- [ ] ループ中断処理
- [ ] タイムアウトの動的設定
- [ ] テストコードの作成とパス
