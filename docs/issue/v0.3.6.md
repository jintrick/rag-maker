# Issue v0.3.6

## 前提知識
- docs/Architecture/Architecture.md
- .gemini/commands/rag.toml
- .gemini/commands/ask.toml

## 現状の問題点
- ローカル文書をナレッジベースに取り込む際、今のところHTML文書にしか対応していないが、実際にはWordやPDF、ただのテキストファイルなども含まれるかもしれない。

## 解決策の概要
- Microsoftが提供するPythonライブラリ「MarkItDown」を導入し、Word, PDF, テキストファイルなど様々なファイルタイプをMarkdownに変換する機能を追加する。これにより、RAGMakerが対応可能なドキュメント形式を拡張する。


## 解決策の詳細

この解決策は、以下の主要な変更から構成されます。

### 1. 必要なライブラリの導入

- `requirements.txt` に `markitdown` と `yomitoku` を追加し、プロジェクトの依存関係として管理します。

### 2. 新しい変換ツールの作成 (`document_converter.py`)

`tools/` ディレクトリに新しいツール `document_converter.py` を作成します。

- **機能**: 指定された入力ファイルパスのドキュメントを読み込み、ファイルタイプに応じて適切なライブラリ（MarkItDownまたはYomitoku）を使用してMarkdown形式に変換し、指定された出力ディレクトリに保存します。
    - **PDFファイルの場合**: Yomitokuを使用してMarkdownに変換します。**（注: Yomitokuはレイアウト解析に基づき、段落、表、画像などの論理構造単位でドキュメントを分割する機能を持っています。これにより、長大なPDF文書も意味のある単位で処理可能です。）**
- **インターフェース**: コマンドライン引数 (`--input-path`, `--output-dir`) を受け取り、処理結果をJSON形式で標準出力します。
- **エラーハンドリング**: サポートされていないファイル形式や変換エラーが発生した場合に、適切なエラーメッセージを返します。

### 3. `/rag` コマンドワークフローへの組み込み

`/rag` コマンドのワークフロー（`.gemini/commands/rag.md`）を更新し、`document_converter.py` ツールを組み込みます。

- ローカルファイルパスが指定された場合、`http_fetch` や `github_fetch` の前に `document_converter.py` を実行し、対象ファイルをMarkdownに変換します。
- 変換されたMarkdownファイルは、既存のMarkdown処理フローに引き渡されます。


## 参考とすべきスクリプト等

- `tools/html_to_markdown.py`: HTMLからMarkdownへの変換ロジックの参考になります。
- `tools/entry_discovery.py`: `discovery.json` の更新方法の参考になります。

## テスト方法

Julesへ。

以下の手順で、今回作成する `document_converter.py` ツールと、`/rag` コマンドへの組み込みをテストしてください。テスト関連のファイルはすべて `test/` ディレクトリに作成・配置してください。

### 1. `document_converter.py` の単体テスト

様々なファイル形式（Word, PDF, テキストファイルなど）が正しくMarkdownに変換されることを確認します。

- **テストファイル**: `test/test_document_converter.py` (新規作成)
- **実行コマンド**: `python -m unittest test/test_document_converter.py`
- **確認事項**:
    - サポートされている各ファイル形式のテストファイルを準備し、`document_converter.py` を実行してMarkdownが出力されることを確認します。
    - **特にPDFファイルについては、Yomitokuが画像ベースのPDFも適切に処理し、テキストを抽出できることを確認します。**
    - 出力されたMarkdownの内容が、元のドキュメントの内容を適切に反映していることを検証します。
    - サポートされていないファイル形式が入力された場合に、適切にエラーが返されることを確認します。

### 2. `/rag` コマンドとの統合テスト

`/rag` コマンドが、ローカルのWordやPDFファイルを正しく取り込み、ナレッジベースを構築できることを確認します。

- **テストファイル**: `test/test_rag_workflow_with_converter.py` (新規作成)
- **実行コマンド**: `python -m unittest test/test_rag_workflow_with_converter.py`
- **確認事項**:
    - テスト用のWordファイルやPDFファイルを含むディレクトリを準備します。
    - `/rag` コマンドを実行し、これらのファイルが正しくMarkdownに変換され、ナレッジベースに登録されることを確認します。
    - 最終的に生成された `discovery.json` に、変換されたドキュメントの情報が正しく含まれていることを検証します。

## 実装状況

## Appendix

### MarkItDown API

MarkItDownは、Python APIとCLIの両方を提供します。

#### Python API

`MarkItDown` クラスのコンストラクタと `convert` メソッドの主なパラメータは以下の通りです。

**`MarkItDown` クラスコンストラクタのパラメータ:**

*   `enable_plugins` (`bool`, デフォルト `False`): `True` に設定すると、プラグインが有効になります。
*   `docintel_endpoint` (`str`): Azure Document Intelligence のエンドポイントURL。
*   `llm_client`: LLMクライアントのインスタンス（例: `OpenAI()`）。画像の説明生成などに使用されます。
*   `llm_model` (`str`): 使用するLLMモデルの名前（例: `"gpt-4o"`）。
*   `llm_prompt` (`str`): LLMに渡すオプションのカスタムプロンプト。

**`convert` メソッドのパラメータ:**

*   `path` (`str`): 変換するファイルのパス。

**使用例:**

```python
from markitdown import MarkItDown

# 基本的な変換
md = MarkItDown()
result = md.convert("path-to-file.ext")
markdown_content = result.text_content # Markdownコンテンツは result.text_content に含まれる

# LLM連携の例（画像の説明生成など）
# from openai import OpenAI
# client = OpenAI(api_key="your-openai-api-key")
# md_with_llm = MarkItDown(llm_client=client, llm_model="gpt-4o")
# result_with_llm = md_with_llm.convert("image.jpg")
# print(result_with_llm.text_content)
```

#### CLI Usage

`markitdown` コマンドラインツールは、ドキュメント変換のためのシンプルなインターフェースを提供します。

**主なオプション:**

*   `<path-to-file>`: 変換するファイルのパス。
*   `-o <output-file>`: 出力ファイルを指定します。指定しない場合、標準出力に結果が出力されます。
*   `-d`: Document Intelligence を有効にします。
*   `-e "<your_docintel_endpoint>"`: Azure Document Intelligence のエンドポイントを指定します。
*   `--list-plugins`: インストールされているプラグインを一覧表示します。
*   `--use-plugins`: プラグインを有効にします。

**使用例:**

```bash
markitdown path-to-file.pdf > document.md
# または
markitdown path-to-file.pdf -o document.md
```

---

### Yomitoku API

Yomitokuは主にCLIツールとして提供され、日本語に特化したAI-OCRおよび文書画像解析エンジンです。

#### CLI Usage

`yomitoku` コマンドの主なパラメータは以下の通りです。

**主なパラメータ:**

*   `${path_data}`: 解析する画像ファイルまたは画像を含むディレクトリへのパス。ディレクトリの場合、サブディレクトリ内の画像も処理されます。
*   `-f`, `--format` (`str`): 出力ファイル形式を指定します。サポートされる形式は `json`, `csv`, `html`, `md`, `pdf` (検索可能なPDF) です。
*   `-o`, `--outdir` (`str`): 出力ディレクトリを指定します。存在しない場合は作成されます。
*   `-v`, `--vis`: 可視化された解析結果を画像として出力します。
*   `-l`, `--lite`: 軽量モデルで推論を実行し、処理を高速化します（精度がわずかに低下する可能性があります）。
*   `-d`, `--device` (`str`): モデル実行に使用するデバイスを指定します（デフォルト: `cuda`）。GPUが利用できない場合は `cpu` にフォールバックします。
*   `--ignore_line_break`: 画像内の改行を無視し、段落内のテキストを連結します（デフォルト: 画像の改行を保持）。
*   `--figure_letter`: 検出された図や表に含まれるテキストを出力ファイルにエクスポートします。
*   `--figure`: 検出された図や画像をファイルに出力します。
*   `--encoding` (`str`): 出力ファイルの文字エンコーディングを指定します（例: `utf-8`, `shift-jis`）。
*   `--combine`: 複数ページのPDFが入力された場合、すべてのページの予測結果を単一の出力ファイルに統合します。
*   `--ignore_meta`: ヘッダー/フッターテキストを出力ファイルから除外します。

**分割機能と分割単位:**

Yomitokuは、レイアウト解析に基づき、ドキュメントを意味のある論理構造単位で分割する機能を持っています。

*   **画像ブロック分割:** 入力画像を複数のブロックに分割し、並列処理で高速化します。
*   **レイアウト解析:** 文書全体の構造を理解し、段落、表、画像などの位置関係を解析します。これにより、文書の意味的な構造を壊さずに情報を抽出します。
*   **表構造認識:** 文書内の表を検出し、その構造（行、列、セル）を認識します。
*   **テキスト検出・認識:** レイアウト分割後にテキストの検出と認識を行います。
*   **図表・画像抽出:** 文書内に含まれる図や画像を抽出して出力できます。

**使用例:**

```bash
yomitoku ${path_data} -f md -o ${output_dir} --combine
```