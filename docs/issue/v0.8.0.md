# Issue v0.8.0: Web 収集における Playwright 導入とオートフォールバック・パイプラインの構築

## 前提知識
- `docs/Architecture/Architecture.md` (全体アーキテクチャ)
- `.gemini/commands/rag.md` (オーケストレーション定義)
- `src/ragmaker/tools/http_fetch.py` (既存の静的フェッチャー)
- `discovery.json` (ツールインターフェース定義)
- `pyproject.toml` (依存関係管理)

## 経緯
現在の Web ソース取得プロセスは `http_fetch` による静的な HTML 解析のみに依存しており、JavaScript 駆動の SPA サイト（例：Google Cloud などのドキュメントサイト）では情報の網羅的な収集が不可能である。一方で、全サイトにヘッドレスブラウザを適用するのはオーバーヘッドが大きすぎる。
本 Issue では、軽量な `http_fetch` を優先し、その失敗や SPA 検知をトリガーとして重量級の `browser_fetch` (Playwright) へ自動的に切り替わる「オートフォールバック・パイプライン」を構築し、RAG 構築の確実性と効率性を両立させる。

## 現状の問題点
- `http_fetch` が SPA サイトで空のドキュメントリストを返しても、オーケストレーター（rag.md）がそれを検知して対処する術がない。
- `http_fetch` に「自身の技術的限界（SPA等）により取得が不完全であること」を上位層に伝える信号（Signal）が実装されていない。
- SPA サイトを確実に攻略するための Playwright ベースのツールがプロジェクトに存在しない。

## ゴール（完了の定義）
実装担当者は、完了報告前に以下の項目をすべて確認し、チェックを入れ、この文書を更新してcommitすること。
- [x] `src/ragmaker/tools/http_fetch.py` に SPA 検出およびフォールバック推奨フラグ（メタデータへのステータス付与）が実装されている。
- [x] `src/ragmaker/tools/browser_fetch.py` が新規作成され、Playwright によるレンダリング後の情報取得が可能になっている。
- [x] `browser_fetch` のコマンドライン引数（`--url`, `--base-url`, `--output-dir`, `--recursive`, `--depth`）および出力（`catalog.json`）が `http_fetch` と完全な互換性を持っている。
- [x] `.gemini/commands/rag.md` のワークフローが更新され、`http_fetch` の結果に応じた `browser_fetch` への条件付きフォールバックが定義されている。
- [x] `discovery.json` に `browser_fetch` の定義が追加されている。
- [x] `pyproject.toml` に `ragmaker-browser-fetch` スクリプトが登録されている（`playwright` 依存関係は既に存在することを確認済み）。
- [x] 新規作成したテスト `test/test_browser_fetch.py` および既存のテストがすべてパスしている。

## 解決策の概要
「検知」「実行」「指揮」の三層でフォールバックを実現する。
1. **検知**: `http_fetch` が結果のカタログ JSON に `fallback_recommended` ステータスを埋め込む。
2. **実行**: `browser_fetch` が Playwright を用いて、`http_fetch` が取りこぼした動的コンテンツを回収する。
3. **指揮**: `rag.md` が前段の出力を評価し、必要に応じて次段のツールを起動するプロンプト駆動の条件分岐を行う。

## 解決策の詳細

### 1. `src/ragmaker/tools/http_fetch.py` の修正
`WebFetcher.run` メソッドおよび `main` 関数を修正し、以下の条件のいずれかを満たす場合にメタデータの `status` を `fallback_recommended` に設定する。

- **判定条件**:
    1. `readable-cli` の実行に失敗した（終了コードが 0 以外）。
    2. 取得された `documents` リストが空である。
    3. 抽出された Markdown コンテンツの長さが極端に短い（例: 200文字未満）一方で、元の HTML ソースが一定以上のサイズ（例: 2000文字以上）を持っている。
    4. HTML ソース内に SPA 特有のパターン（例: `<body>` 直下が `<div id="root"></div>` のみで実コンテンツがない等）を検出した。
- **出力形式**:
    ```json
    {
      "documents": [],
      "metadata": {
        "source": "http_fetch",
        "status": "fallback_recommended",
        "reason": "SPA_DETECTED",
        "details": "Content length too short compared to HTML source size."
      }
    }
    ```

### 2. `src/ragmaker/tools/browser_fetch.py` の新規作成
Playwright を使用して動的な Web サイトからコンテンツを抽出するツールを実装する。

- **技術スタック**: `playwright.async_api`, `asyncio`, `markdownify`, `beautifulsoup4`.
- **インターフェース**: `http_fetch.py` と同一の引数構成とする。
- **主要な処理フロー**:
    1. `asyncio.run()` をエントリーポイントとして呼び出す。
    2. `chromium.launch(headless=True)` でブラウザを起動。
    3. ページ遷移後、`page.wait_for_load_state("networkidle")` で通信の収束を待機。
    4. **DOM 抽出 (JavaScript)**: `page.evaluate()` 内で以下のロジックを実行する。
        - `main`, `article` タグ、または `role="main"` を持つ要素を優先的に特定。
        - 不要な要素（`script`, `style`, `nav`, `footer`, `iframe`, `ads` 等）を DOM から削除。
        - クリーンアップ後の `innerHTML` と、ページ内の全 `<a>` タグの `href` を抽出。
    5. **Markdown 変換**: 抽出した HTML を Python 側の `markdownify` で変換。
    6. **再帰処理**: レンダリング後の DOM から得られたリンクに対して、指定された `depth` まで同様の処理を繰り返す。
- **互換性**: 出力ディレクトリの構造、`catalog.json` のフォーマットを `http_fetch.py` と完全に一致させる。

### 3. オーケストレーションの更新
`.gemini/commands/rag.md` の「Webソースの場合」のセクションを以下のように更新し、エージェントが自律的にフォールバックを判断できるようにする。

- **更新内容**:
    - `http_fetch` の実行後、その出力を評価する。
    - `documents` が空、または `metadata.status == "fallback_recommended"` の場合、追加で `browser_fetch` を実行するよう指示を明文化する。
    - `browser_fetch` の出力で既存の `.tmp/cache/catalog.json` を上書き（またはマージ）するように構成する。

### 4. 設定と登録
- `discovery.json`: `browser_fetch` の定義を追加。説明文に「SPAやJavaScript駆動のサイト用」であることを明記。
- `pyproject.toml`: `[project.scripts]` に `ragmaker-browser-fetch = "ragmaker.tools.browser_fetch:main"` を追加。

## 参考とすべきスクリプト等
- `src/ragmaker/tools/http_fetch.py` (構造のベース)
- `src/ragmaker/io_utils.py` (エラーハンドリング、JSON出力用)
- `test/test_http_fetch.py` (テストの構成案)

## テスト方法
実装担当者は、以下のテストを実施し、結果を確認すること。

1. **単体テスト**: `test/test_browser_fetch.py` を作成。
    - 静的な HTML (Mock) に対する正常系。
    - `setTimeout` 等で遅延描画されるコンテンツが正しく取得できるかの検証。
    - 再帰的なリンク取得の検証。
2. **統合テスト**:
    - SPA サイト（例: `https://antigravity.google/`）を対象に `http_fetch` を実行し、`fallback_recommended` が返ることを確認。
    - その後、`browser_fetch` を実行し、正しくコンテンツが Markdown 化されることを確認。
3. **ワークフローテスト**:
    - `rag` コマンドを通じて、エージェントが自動的にフォールバックを選択し、最終的なナレッジベースを構築できることを確認。

## 実装状況
実装担当者は、完了報告前に以下の項目をすべて確認し、チェックを入れ、この文書を更新してcommitすること。
- [x] `http_fetch.py` のフォールバック判定実装完了
- [x] `browser_fetch.py` の実装完了 (Playwright/asyncio)
- [x] `rag.md` のワークフロー更新完了
- [x] `discovery.json` への登録完了
- [x] `pyproject.toml` へのスクリプト登録完了
- [x] 全テストのパス確認
